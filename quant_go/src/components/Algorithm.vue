<template>
<!-- Author: Neil Kelly
NetID: nk220 -->
    <div>
        Executed {{this.orders.length}} trades,
        currently holding {{this.currPositions.length}} positions

        <FinancialGraph id = 'graph' :chartData = 'this.graphData'/>
    </div>
    
</template>

<script>
//wrapper component for FinancialGraph + algorithm calculations
import FinancialGraph from './FinancialGraph';

export default {
  name: 'Algorithm',
  data(){
      return {
            tempGraphData : {
                labels: ['a', 'b', 'c', 'd', 'e'],
                    datasets: [
                        {
                            type: 'line',
                            label: 'Price Over Time',
                            data: [2, 3, 4, 3.5, 1.8],
                        },
                        {
                            type: 'scatter',
                            label: 'Buy Points',
                            data: [{x:'a', y:3}, {x:'b', y:4}, {x:'c', y:5}, {x:'d', y:6}, {x:'e', y:7}],
                            showLine: false
                        }
                    ]
            },

        //object passed to FinancialGraph ChartJS component
        graphData : {},

        //buy and sell orders generated by algorithm
        orders : [],

        //only numbers, null if no order on that day, used to display on graph
        graphBuyData: [],
        graphSellData: [],

        //currently owned stocks + og purchase price
        currPositions : []
      }
  },

  components: {
      FinancialGraph
  },

  props: {
      //all price data fetched from TwelveData, including meta+values
    data: {},
    //user inputted parameters, including stock/algo params
    param: {}
  },

  mounted(){
      //this.generateGraphData();
  },

  watch : {
      data : function(){
          console.log("Watched data");
          this.generateGraphData();
      },

      param : function(){
          console.log('Watched param');
          this.generateGraphData();
      }
  },

  methods : {
      generateGraphData(){
          console.log("Generating Graph Data");

          this.clearPreviousTrades();
          this.meanReversion();

          this.graphData = {
              labels : this.extractLabels(),
              datasets: [
                  {
                      type: 'line',
                      label: 'Price Over Time',
                      data: this.extractPrices(),
                      tension : 0.0
                  },
                  {
                      type: 'scatter',
                      label: 'Buy Orders',
                      data: this.graphBuyData,
                      showLine: false,
                      pointBackgroundColor: 'rgb(0, 200, 0)',
                      pointRadius: 6
                  },
                  {
                      type: 'scatter',
                      label: 'Sell Orders',
                      data: this.graphSellData,
                      showLine: false,
                      pointBackgroundColor: 'rgb(200, 0, 0)',
                      pointRadius: 6

                  }
              ]
          }
          console.log("Graph data generated");

          this.emitResults();
      },

      clearPreviousTrades(){

          console.log('CLEARING PREV TRADES');
          this.orders = [];
          this.currPositions = [];
          this.graphBuyData = [];
          this.graphSellData = [];

        console.log(this.param.moving_avg_length);

        let correctionFactor = 1/this.convertIntervalToDays();
          for(let i = 0; i < parseInt(this.param.moving_avg_length)*correctionFactor; i++){
              this.graphBuyData.push(null);
              this.graphSellData.push(null);
          }

        
          console.log('buy length at start: ' + this.graphBuyData.length);
          console.log('sell length at start: ' + this.graphSellData.length);
      },

      emitResults(){
          let algoResults = {
              initialPrice : parseFloat(this.data.values[this.data.values.length-1].price),
              finalPrice : parseFloat(this.data.values[0].price),
              currPositions : this.currPositions
          }
          this.$emit('algo-results', algoResults);
      },

      extractLabels(){
          console.log("Extracting Labels");
          let dateLabels = [];

          this.data.values.forEach(val => {
              dateLabels.unshift(val.datetime);
          });
          return dateLabels;
      },

      extractBuyOrders(){
          let buyOrders = [];
          return buyOrders;
      },

      extractSellOrders(){
          let sellOrders = [];
          return sellOrders;
      },

      extractPrices(){
          console.log("Extracting Prices");
          let allPriceArray = [];
          //console.log(this.data.values);
          this.data.values.forEach(val => {
              allPriceArray.unshift(val.price);
          });
          return allPriceArray;
      },
      
      meanReversion(){
          //intervals, moving average length, and params are doubles in terms of days
          
          //number of days of simple moving average to consider
          let windowLength = parseFloat(this.param.moving_avg_length);


          //number of days each interval (time between stock price updates) is
          let intervalLength = this.convertIntervalToDays();

          let intervalsPerWindow = windowLength / intervalLength;

          console.log('window length = ' + windowLength);
          console.log('interval length = ' + intervalLength);

          console.log('intervalsPerWindow = ' + intervalsPerWindow);

          let slidingWindow = {
              sum : 0,
              mean : 0,
              standard_deviation : 0,
              values : []
          }

          //build arr of numerical prices from earliest to latest
          let allPrices = [];
          for(let j = this.data.values.length-1; j >= 0; j--){
              allPrices.push(parseFloat(this.data.values[j].price));
          }

          //first, populate initial sliding window
          
          let i = 0;

          for(i; i < intervalsPerWindow; i++){
              slidingWindow.values.push(allPrices[i]);
              slidingWindow.sum += allPrices[i];
          }

          this.setMean(slidingWindow);
          this.setStandardDeviation(slidingWindow);

          console.log("sliding window: ");
          console.log(slidingWindow);

          //next iterate through all the remaining data

          //array of obj 
        //   {
        //       entryPrice: num,
        //       sharesPurchased: num
        //   }          

          for(i; i < allPrices.length; i++){
              const currPrice = allPrices[i];
              let buyAtCurrPrice = false;
              let sellAtCurrPrice = false;

              slidingWindow.sum -= slidingWindow.values.shift();
              slidingWindow.sum += currPrice;

              this.setMean(slidingWindow);
              this.setStandardDeviation(slidingWindow);
            
              if(currPrice < (slidingWindow.mean-(slidingWindow.standard_deviation * parseFloat(this.param.moving_avg_entry)))){
                  //BUY 1000 USD 
                  buyAtCurrPrice = true;
                  let newOrder = {
                      orderType : 'buy',
                      symbol : this.data.meta.symbol,
                      amountSpent : 1000,
                      sharesPurchased : 1000/currPrice,
                      entryPrice : currPrice
                  }

                //   console.log('buy order');
                //   console.log(newOrder);

                  this.orders.push(newOrder);

                  let newPosition = {
                      entryPrice: currPrice,
                      sharesPurchased: 1000/currPrice
                  }
                  this.currPositions.push(newPosition);
              }

              //see if any current positions can be sold

              
              

              slidingWindow.values.push(this.data.values[i].price);

              if(buyAtCurrPrice){
                  this.graphBuyData.push(currPrice);
              }
              else{
                  this.graphBuyData.push(null);
              }

              if(sellAtCurrPrice){
                  this.graphSellData.push(currPrice);
              }
              else{
                  this.graphSellData.push(null);
              }
          }

      },

      setMean(slidingWindow){
          slidingWindow.mean = slidingWindow.sum/slidingWindow.values.length;
      },

      setStandardDeviation(slidingWindow){
          let errorSum = 0;

          slidingWindow.values.forEach(val => {
              errorSum += Math.pow((val-slidingWindow.mean), 2);
          });

          let variance = errorSum/slidingWindow.values.length;

          slidingWindow.standard_deviation = Math.sqrt(variance);
      },

    //NOT SIMPLY 24hrs/interval, only counts intervals during trading hours
      convertIntervalToDays(){
          if(this.data.meta.interval === '15min'){
              return 1/26;
          }
          else if(this.data.meta.interval === '30min'){
              return 1/13;
          }
          else if(this.data.meta.interval === '45min'){
              return 1/9;
          }
          else if(this.data.meta.interval === '1h'){
              return 1/7;
          }
          else if(this.data.meta.interval === '2h'){
              return 1/4;
          }
          else if(this.data.meta.interval === '4h'){
              return 1/2;
          }
          else if(this.data.meta.interval === '1day'){
              return 1.0;
          }
          else if(this.data.meta.interval === '1week'){
              return 5.0;
          }
          else if(this.data.meta.interval === '1month'){
              console.log('this should never happen');
              return 30.0;
          }
          else{
              console.log('this should never happen');
          }
      }
  }
}
</script>

<style>
    #graph{
        border: 10px solid black;
        max-width: 90%;
        margin: 5%;
    }
</style>
